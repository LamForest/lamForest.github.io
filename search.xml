<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>GAMES202作业2旋转部分</title>
      <link href="2021/05/05/cg/games202-zuo-ye-2-xuan-zhuan-bu-fen/"/>
      <url>2021/05/05/cg/games202-zuo-ye-2-xuan-zhuan-bu-fen/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文是写在做完<a href="https://www.bilibili.com/video/BV1YK4y1T7yY">GAMES202 高质量实时渲染</a>作业2之后的总结。通过不严谨的数学公式，从球谐的旋转不变性出发，一步步推导出如何求旋转后的系数${c_l^m}^{\prime}$。</p><blockquote><p>非常感谢闫老师和助教们的课程和代码框架！！！</p></blockquote><p>效果展示：</p><p>(注：环境光为Cornell Box)</p><p><img src="https://gitee.com/getleft/pics/raw/master/imgs/%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%97%8B%E8%BD%AC%E6%95%88%E6%9E%9C_small.gif" alt=""></p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>定义在球面上的环境光 $L_i(\omega_i)$可以被展开成球谐基函数的线性组合：</p><script type="math/tex; mode=display">L_i(\omega_i) = \sum_{l  = 0}^{+\infty} \sum_{m  = -l}^{l} c_l^mB_l^m(\omega_i)</script><p>假设现在有一个旋转矩阵 $R^{-1}$，现在有一个旋转矩阵，将环境光 $L_i(\omega_i)$进行了旋转，得到了 $L_i(R\omega_i)$。</p><blockquote><p>注：将$y = x^2$向x轴正半轴方向移动了a个单位后，变为了$y = (x-a)^2$，而不是$y = (x+a)^2$，旋转也是这个道理。</p></blockquote><p><strong>问题来了</strong>，<strong>如何求得 $L_i(R\omega_i)$ 的球谐系数${c_l^m}^{\prime}$？</strong></p><p>最简单的想法，重新计算 $L_i(R\omega_i)$ 对每个球谐基函数的投影：</p><script type="math/tex; mode=display">{c_l^m}^{\prime} = \int_{\Omega} B_l^m(\omega_i) L_i(R\omega_i) d\omega_i</script><p>假如环境光源在每一帧都在旋转，那么每一帧渲染之前，都要进行这么一个积分，这是无法接受的。</p><blockquote><p>回顾之前的内容，该积分使用的是黎曼和的形式求解，复杂度很高。</p></blockquote><p>是否有更简单的方法计算${c_l^m}^{\prime}$ 呢？</p><p><strong>比如，是否存在某个方法，可以直接从${c_l^m}$得到${c_l^m}^{\prime}$呢？</strong></p><p>这就是本文探讨的话题。</p><h2 id="什么是旋转不变性"><a href="#什么是旋转不变性" class="headerlink" title="什么是旋转不变性"></a>什么是旋转不变性</h2><p>对于某个球谐基函数$B_l^m(\omega_i)$，假设现在有一个旋转矩阵 $R^{-1}$ 将$B_l^m(\omega_i)$进行了旋转，</p><blockquote><p>注：旋转应该是指，按照空间中过原点的某一个轴旋转了某个角度，由于环境光是无限远的，所以转轴虽然在空间中任意位置，但可以视作在原点。</p></blockquote><p>那么旋转后的函数的表达式为$B_l^m(R^{}\omega_i)$。</p><p><strong>旋转不变性</strong>指的是，$B_l^m(R\omega_i)$可以被拆分成同阶（band）的其他基函数的线性组合，而与其他阶的基函数无关，即：</p><script type="math/tex; mode=display">B_l^m(R\omega_i) = \sum_{k  = -l}^{l} a_k B_l^m(\omega_i) \tag 1</script><h2 id="从旋转不变性出发，开始推导"><a href="#从旋转不变性出发，开始推导" class="headerlink" title="从旋转不变性出发，开始推导"></a>从旋转不变性出发，开始推导</h2><p>根据球谐展开的概念，对环境光 $L_i(\omega_i)$，我们有：</p><script type="math/tex; mode=display">\begin{align}L_i(\omega_i) &= \sum_{l  = 0}^{+\infty} \sum_{m  = -l}^{l} c_l^mB_l^m(\omega_i) \\\end{align}</script><p>在这篇文章里，我们关注 $l = 1$的情况，忽略其他阶，则上式可以写成：</p><script type="math/tex; mode=display">\begin{align}L_i(\omega_i) &= ... + c_1^{-1}B_1^{-1}(\omega_i) + c_1^{0}B_1^{0}(\omega_i) + c_1^{1}B_1^{1}(\omega_i) +...\end{align}</script><p>在继续进行之前，要先达成一个共识（我不确定这是否需要证明）：</p><ul><li><p>考虑这么一件事情：如果将 $L_i(R\omega_i)$在 $B_l^m(R\omega_i)$上进行分解，所得到的球谐系数是多少呢？</p></li><li><p>由于我们将光源和球谐基函数同时用 $R$ 进行了旋转，那么它们之间的相对关系应该是不会发生变化的，也就是球谐系数仍然是 $c_l^m$：</p></li></ul><script type="math/tex; mode=display">c_l^m = \int_{\Omega} B_l^m(R\omega_i) L_i(R\omega_i) d\omega_i</script><p>有了这个共识，我们就可以直接获得 $L_i(R\omega_i)$在 $B_l^m(R\omega_i)$上进行分解的球谐系数，就是${c_l^m}$（同样只关注 第1阶）：</p><script type="math/tex; mode=display">\begin{align}L_i(R\omega_i) &= ... + c_1^{-1}B_1^{-1}(R\omega_i) + c_1^{0}B_1^{0}(R\omega_i) + c_1^{1}B_1^{1}(R\omega_i) + ... \tag 2\end{align}</script><p>有了公式（2）后，借助球谐函数的旋转不变性（式1），我们可以将$B_l^m(R\omega_i)$ 表示为同band其他基函数的线性组合：</p><script type="math/tex; mode=display">\begin{align}B_1^{-1}(R\omega_i) &= \sum_{k  = -1}^{1} x_k B_1^k(\omega_i) =  x_{-1}B_1^{-1}(\omega_i) + x_{0}B_1^{0}(\omega_i) + x_{1}B_1^{1}(\omega_i) \tag 3\\B_1^{0}(R\omega_i) &= \sum_{k  = -1}^{1} y_k B_1^k(\omega_i) =  y_{-1}B_1^{-1}(\omega_i) + y_{0}B_1^{0}(\omega_i) + y_{1}B_1^{1}(\omega_i)\\B_1^{1}(R\omega_i) &= \sum_{k  = -1}^{1} z_k B_1^k(\omega_i) =  z_{-1}B_1^{-1}(\omega_i) + z_{0}B_1^{0}(\omega_i) + z_{1}B_1^{1}(\omega_i)\end{align}</script><p>假设 $x_k,y_k, z_k$全部已知，那将上面的式子代入式（2），有：</p><script type="math/tex; mode=display">\begin{aligned}L_i(R\omega_i) = ... &+ c_1^{-1}\left(x_{-1}B_1^{-1}(\omega_i) + x_{0}B_1^{0}(\omega_i) + x_{1}B_1^{1}(\omega_i) \right) \\&+ c_1^{0} \left(y_{-1}B_1^{-1}(\omega_i) + y_{0}B_1^{0}(\omega_i) + y_{1}B_1^{1}(\omega_i) \right)\\&+ c_1^{1} \left(z_{-1}B_1^{-1}(\omega_i) + z_{0}B_1^{0}(\omega_i) + z_{1}B_1^{1}(\omega_i) \right)\\&+...\end{aligned}</script><p>进行一下合并同类项：</p><script type="math/tex; mode=display">\begin{align}L_i(R\omega_i) = ... &+ (c_1^{-1}x_{-1} + c_1^{0}y_{-1} + c_1^{1}z_{-1})B_1^{-1}(\omega_i)\\&+ (c_1^{-1}x_{0} + c_1^{0}y_{0} + c_1^{1}z_{0})B_1^{0}(\omega_i)\\&+ (c_1^{-1}x_{1} + c_1^{0}y_{1} + c_1^{1}z_{1})B_1^{1}(\omega_i)\\&+...\end{align}</script><p>令 ${c_1^{-1}}^{\prime} = (c_1^{-1}x_{-1} + c_1^{0}y_{-1} + c_1^{1}z_{-1})$ </p><p>${c_1^{0}}^{\prime} = (c_1^{-1}x_{0} + c_1^{0}y_{0} + c_1^{1}z_{0})$</p><p> ${c_1^{1}}^{\prime} = (c_1^{-1}x_{1} + c_1^{0}y_{1} + c_1^{1}z_{1})$ </p><p>则上式被重写成：</p><script type="math/tex; mode=display">\begin{align}L_i(R\omega_i) = ... + {c_1^{-1}}^{\prime}B_1^{-1}(\omega_i)+ {c_1^{0}}^{\prime}B_1^{0}(\omega_i)+ {c_1^{1}}^{\prime}B_1^{1}(\omega_i)&+...\end{align}</script><p>这样，我们就得到了旋转之后，各个球谐基函数的系数${c_l^m}^{\prime}$了。</p><hr><p>下一节定义了 $M_R$, 利用 $M_R$可以将 ${c_1^{-1}}^{\prime},{c_1^{0}}^{\prime},{c_1^{1}}^{\prime} $用矩阵乘法表示：</p><script type="math/tex; mode=display">\begin{pmatrix}{c_1^{-1}}^{\prime}\\{c_1^{0}}^{\prime}\\{c_1^{1}}^{\prime}\\\end{pmatrix} = {M_R}^T\begin{pmatrix}c_1^{-1}\\c_1^{0}\\c_1^{1}\\\end{pmatrix} \tag 4</script><h2 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h2><p>之前，我们假设 $x_k,y_k, z_k$全部已知，但是它们其实是未知的，接下来我们来求解它们。</p><p>以式（3）为例，在这里，我们要求的是 $x_{-1}, x_0, x_1$，如何求解呢？</p><p>其实很简单，3个未知数，需要3个方程，我们只需要随便找3个 $n_0, n_1, n_2$代入，得到三元一次方程组。因为 $B_l^m(R\omega_i)$是已知的函数，所以上述方程组可以很简单的解出来：</p><script type="math/tex; mode=display">\begin{align}\left\{\begin{array}{**lr**} B_1^{-1}(Rn_0) =   x_{-1}B_1^{-1}(n_0) + x_{0}B_1^{0}(n_0) + x_{1}B_1^{1}(n_0) \\B_1^{-1}(Rn_1) =   x_{-1}B_1^{-1}(n_1) + x_{0}B_1^{0}(n_1) + x_{1}B_1^{1}(n_1) \\B_1^{-1}(Rn_2) =   x_{-1}B_1^{-1}(n_2) + x_{0}B_1^{0}(n_2) + x_{1}B_1^{1}(n_2) \\\end{array}  \tag 5\right.  \end{align}</script><p>同样的，对于 $y_k$ 和 $z_k$，也带入 $n_0, n_1, n_2$，可以解出$y_k$ 和 $z_k$。（求解$y_k$ 和 $z_k$ 时，选取的 $n_0, n_1, n_2$不一定要是一样的，但是选一样的接下来比较方便）。</p><p><strong>式（5）就是求解 $x_k,y_k, z_k$ 的核心。</strong>本节剩下的内容就是对其进行向量化，变成矩阵运算的形式，这样一来我们可以少写一些循环语句，二来运算也会快一些。</p><hr><p>为了求解 $x_k,y_k, z_k$，我们用到了3个三元一次方程组，每个方程组3个方程，这9个方程可以被写成更简洁的矩阵形式（前提是，三个方程组所用的$n_0, n_1, n_2$是一致的）：</p><script type="math/tex; mode=display">\begin{pmatrix}B_1^{-1}(Rn_0) & B_1^{-1}(Rn_1)  & B_1^{-1}(Rn_2)\\B_1^{0}(Rn_0) & B_1^{0}(Rn_1)  & B_1^{0}(Rn_2)\\B_1^{1}(Rn_0) & B_1^{1}(Rn_1)  & B_1^{1}(Rn_2)\\\end{pmatrix} = \begin{pmatrix}x_{-1} & x_{0} & x_1 \\y_{-1} & y_{0} & y_1 \\z_{-1} & z_{0} & z_1 \\\end{pmatrix}\begin{pmatrix}B_1^{-1}(n_0) & B_1^{-1}(n_1)  & B_1^{-1}(n_2)\\B_1^{0}(n_0) & B_1^{0}(n_1)  & B_1^{0}(n_2)\\B_1^{1}(n_0) & B_1^{1}(n_1)  & B_1^{1}(n_2)\\\end{pmatrix}</script><p>为了表述方便，这里定义了 $P(\omega_i)$ （有的地方也称之为对$\omega_i$的投影）和$M_R$：</p><script type="math/tex; mode=display">P(\omega_i) =\begin{pmatrix}B_1^{-1}(\omega_i) \\B_1^{0}(\omega_i) \\B_1^{1}(\omega_i) \\\end{pmatrix}, M_R = \begin{pmatrix}x_{-1} & x_{0} & x_1 \\y_{-1} & y_{0} & y_1 \\z_{-1} & z_{0} & z_1 \\\end{pmatrix}</script><p>利用新定义的符号，可以继续写成更简洁的形式：</p><script type="math/tex; mode=display">\begin{bmatrix}P(Rn_0) & P(Rn_1) & P(Rn_2)  \end{bmatrix} = M_R\begin{bmatrix}P(n_0) & P(n_1) & P(n_2)\end{bmatrix}</script><p>再记 $S = [P(Rn_0) \quad P(Rn_1) \quad  P(Rn_2)] $ ， $A = [P(n_0) \quad P(n_1) \quad P(n_2) ]$ ：</p><script type="math/tex; mode=display">S = M_R A</script><blockquote><p>注：这里 $S, M_R, A$ 都是3x3的方阵。如果我们在处理2阶球谐函数的时候， $S M_R A$ 都变为了5x5的方阵，3阶则7x7，以此类推。</p></blockquote><p>至此， $M_R$ （即$x_k,y_k, z_k$的矩阵形式）的解变得更加一目了然了：</p><script type="math/tex; mode=display">M_R = S A^{-1} \tag 6</script><blockquote><p>式（6）和式（5）其实是一样的，只是变成了矩阵的形式。</p></blockquote><h2 id="具体的算法"><a href="#具体的算法" class="headerlink" title="具体的算法"></a>具体的算法</h2><p>根据 $M_R = S A^{-1}$，要求 $M_R$ 我们只需算出 $S$ 和 $A$即可。所以有了下面的算法：</p><ol><li>随机选3个向量，这里选择 $n_0 = [0,0,1], n_1 = [0,1,0], n_2 = [1,0,0]$</li><li>代入 $P(\omega_i)$求得 $A$，并得到 $A^{-1}$</li><li>利用旋转矩阵，求得 $Rn_k$，并带入  $P(\omega_i)$求得 $S$</li><li>$M_R = S A^{-1}$</li><li>给定空间中任意一渲染点的坐标 $p$ 的在未旋转光源下的系数 $c = ({c_1^{-1}}^{},{c_1^{0}}^{},{c_1^{1}}^{})^T $, $c^{\prime} = {M_R}^T c$。</li></ol><p>更具体的例子可以参考[1][1]文章尾部的示例一节。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>关于这部分，有几个问题我也没完全搞懂。</p><ol><li><p>乘以 $M_R$还是 ${M_R}^T$？[1][1]和作业2的任务书里面都是乘以 $M_R$，但是我上面的推导的结果是${M_R}^T$，我实现的时候对比了一下，乘以${M_R}^T$的结果才是对的，乘以${M_R}$的结果会使得渲染的结果与模型的旋转方向相反。</p></li><li><p>不同轴，如果使用同一个RotationMatrix进行模型的旋转和球谐系数的计算，会使得它们在绕不同轴旋转。。。这我暂时不能理解。</p></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/51267461">[1]一种简易的旋转球谐函数系数的方法</a>    </p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
            <tag> PRT </tag>
            
            <tag> Real Time Rendering </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>作业2补充</title>
      <link href="2021/05/04/cg/ass2/"/>
      <url>2021/05/04/cg/ass2/</url>
      
        <content type="html"><![CDATA[<h3 id="作业2的提高部分"><a href="#作业2的提高部分" class="headerlink" title="作业2的提高部分"></a>作业2的提高部分</h3><p>Interreflection:<br><img src="CornellBox_inter.gif" alt=""></p><p>Shadowed:<br><img src="正确的旋转效果2.gif" alt=""></p><p>Unshadowed:<br><img src="CornellBox_unshadowed.gif" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
            <tag> PRT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>胡适日记 2021年5月</title>
      <link href="2021/05/01/diary/2021-nian-5-yue/"/>
      <url>2021/05/01/diary/2021-nian-5-yue/</url>
      
        <content type="html"><![CDATA[<h3 id="5-1-5-7"><a href="#5-1-5-7" class="headerlink" title="5.1-5.7"></a>5.1-5.7</h3><h4 id="5-1"><a href="#5-1" class="headerlink" title="5.1"></a>5.1</h4><p>劳动节。学习了PRT。<br>对女朋友生了大气，对不起。</p><h4 id="5-2"><a href="#5-2" class="headerlink" title="5.2"></a>5.2</h4><p>完成了作业2的基础部分的大半（Light项预计算，Shadow和Unshadow的传输项预计算），还是比较容易的，会使用现成的函数就好了。明天要写JS了，想想就蛋疼。还了解到了Yan的黑历史，太牛了。</p><p>晚上吃了10个麦辣鸡翅，真好吃。</p><p>爸爸买了灭蚊灯，不知道效果怎么样，最近被咬的好惨。</p><p>决定在博客上写日记了，不过要好好藏起来</p><h4 id="5-11"><a href="#5-11" class="headerlink" title="5.11"></a>5.11</h4><p>今天看完了 101 P19 和 P20.这两个视频都是科普视频，光场相机，色彩空间，color matching，没啥意思，就是听听看。</p><p>接下来的学习路线是什么呢？</p><p>c++：<br>根据面经和知乎搜藏的查漏补缺</p><p>图形学：</p><ol><li>把当前欠的课补上</li><li>游戏引擎的课程 GAMES 201</li><li>经典论文看原文。哪些是经典的论文呢？大家都推荐的，以及引擎中会用到的一些常用算法</li><li>对于引擎中常用的算法，研究引擎的实现，有需要的时候可以自己实现一下</li><li>opengl的学习，这点暂时没头绪。 learnopengl还是从项目中学习。</li><li>小项目：选自己感兴趣的小项目做一下。比如101的课设</li><li>根据面经查漏补缺</li></ol><p>cv：</p>]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>完美转发 = 引用折叠 + 万能引用 + std::forward</title>
      <link href="2021/04/29/cpp/wan-mei-zhuan-fa-yin-yong-zhe-die-wan-neng-yin-yong-std-forward/"/>
      <url>2021/04/29/cpp/wan-mei-zhuan-fa-yin-yong-zhe-die-wan-neng-yin-yong-std-forward/</url>
      
        <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>完美转发是一个比较简单，却又比较复杂的东西。</p><p>简单之处在于理解<strong>动机</strong>：C++为什么需要完美转发？</p><p>复杂之处在于理解<strong>原理</strong>：完美转发基于万能引用，引用折叠以及std::forward模板函数。</p><p>本文将会结合GCC源码，详细解读完美转发的动机和原理。</p><h3 id="动机：C-为什么需要完美转发？"><a href="#动机：C-为什么需要完美转发？" class="headerlink" title="动机：C++为什么需要完美转发？"></a>动机：C++为什么需要完美转发？</h3><p>我们从一个简单的例子出发。<br>假设有这么一种情况，用户一般使用testForward函数，testForward什么也不做，只是简单的转调用到print函数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span> t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Lvalue ref"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>T <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Rvalue ref"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">testForward</span><span class="token punctuation">(</span>T <span class="token operator">&amp;&amp;</span> v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>     <span class="token function">print</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//v此时已经是个左值了,永远调用左值版本的print</span>    <span class="token function">print</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//本文的重点</span>    <span class="token function">print</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//永远调用右值版本的print</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"======================"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">testForward</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//实参为左值</span>    <span class="token function">testForward</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//实参为右值</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的程序的运行结果：<br><pre class="line-numbers language-none"><code class="language-none">Lvalue refLvalue refRvalue ref&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Lvalue refRvalue refRvalue ref&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>用户希望<code>testForward(x);</code>最终调用的是左值版本的print，而<code>testForward(std::move(x));</code>最终调用的是右值版本的print。</p><p><strong>可惜的是，在testForward中，虽然参数v是右值类型的，但此时v在内存中已经有了位置，所以v其实是个左值！</strong></p><p>所以，<code>print(v)</code>永远调用左值版本的print，与用户的本意不符。<code>print(std::move(v));</code>永远调用右值版本的print，与用户的本意也不符。只有<code>print(std::forward&lt;T&gt;(v));</code>才符合用户的本意，这就是本文的主题。</p><p>不难发现，本质问题在于，左值右值在函数调用时，都转化成了左值，使得函数转调用时无法判断左值和右值。</p><p>在STL中，随处可见这种问题。比如C++11引入的<code>emplace_back</code>，它接受左值也接受右值作为参数，接着，它转调用了空间配置器的construct函数，而construct又转调用了<code>placement new</code>，<code>placement new</code>根据参数是左值还是右值，决定调用拷贝构造函数还是移动构造函数。</p><p>这里要保证从<code>emplace_back</code>到<code>placement new</code>，参数的左值和右值属性保持不变。这其实不是一件简单的事情。</p><h3 id="前置知识-引用折叠-万能引用"><a href="#前置知识-引用折叠-万能引用" class="headerlink" title="前置知识 引用折叠 万能引用"></a>前置知识 引用折叠 万能引用</h3><p>C++ Primer 里面写的比较容易理解，在P608（我的是第5版）。<br>略</p><h3 id="原理：完美转发"><a href="#原理：完美转发" class="headerlink" title="原理：完美转发"></a>原理：完美转发</h3><p>std::forward不是独自运作的，在我的理解里，完美转发 = std::forward + 万能引用 + 引用折叠。三者合一才能实现完美转发的效果。</p><p>std::forward的正确运作的前提，是引用折叠机制，为T &amp;&amp;类型的万能引用中的模板参数T赋了一个恰到好处的值。我们用T去指明std::forward<T>的模板参数，从而使得std::forward返回的是正确的类型。</p><p>当然，我们还是先回到一开始的例子。</p><h4 id="testForward-x"><a href="#testForward-x" class="headerlink" title="testForward(x)"></a>testForward(x)</h4><p>回到上面的例子。先考虑<code>testForward(x);</code>这一行代码。</p><h5 id="step-1-实例化testForward"><a href="#step-1-实例化testForward" class="headerlink" title="step 1 实例化testForward"></a>step 1 实例化testForward</h5><p>根据万能引用的实例化规则，实例化的testForward大概长这样：<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">T <span class="token operator">=</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span><span class="token keyword">void</span> <span class="token function">testForward</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span> <span class="token operator">&amp;&amp;</span> v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">print</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br>又根据引用折叠，上面的等价于下面的代码：<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">T <span class="token operator">=</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span><span class="token keyword">void</span> <span class="token function">testForward</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span> v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">print</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br>如果你正确的理解了引用折叠，那么这一步是很好理解的。</p><h5 id="step-2-实例化std-forward"><a href="#step-2-实例化std-forward" class="headerlink" title="step 2 实例化std::forward"></a>step 2 实例化std::forward</h5><blockquote><p>注：C++ Primer：forward必须通过显式模板实参来调用，不能依赖函数模板参数推导。</p></blockquote><p>接下来我们来看下<code>std::forward</code>在libstdc++中的实现：<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token number">68</span>   <span class="token comment">/**69    *  @brief  Forward an lvalue.70    *  @return The parameter cast to the specified type.71    *72    *  This function is used to implement "perfect forwarding".73    */</span><span class="token number">74</span>   <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">_Tp</span><span class="token operator">></span><span class="token number">75</span>     <span class="token keyword">constexpr</span> _Tp<span class="token operator">&amp;&amp;</span><span class="token number">76</span>     <span class="token function">forward</span><span class="token punctuation">(</span><span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token operator">::</span>remove_reference<span class="token operator">&lt;</span>_Tp<span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">&amp;</span> __t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token number">77</span>     <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>_Tp<span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>__t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>由于Step1中我们调用<code>std::forward&lt;int &amp;&gt;</code>，所以此处我们代入<code>T = int &amp;</code>，我们有：<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span> <span class="token operator">&amp;&amp;</span> <span class="token comment">//折叠</span><span class="token function">forward</span><span class="token punctuation">(</span><span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token operator">::</span>remove_reference<span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span><span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">&amp;</span> __t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token comment">//remove_reference的作用与名字一致，不过多解释</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span> <span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>__t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//折叠</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>这里又发生了2次引用折叠，所以上面的代码等价于：<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span> <span class="token comment">//折叠</span><span class="token function">forward</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span> __t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token comment">//remove_reference的作用与名字一致，不过多解释</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>__t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//折叠</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>所以最终<code>std::forward&lt;int &amp;&gt;(v)</code>的作用就是将参数强制转型成<code>int &amp;</code>，而<code>int &amp;</code>为左值。所以，调用左值版本的print。</p><h4 id="testForward-std-move-x"><a href="#testForward-std-move-x" class="headerlink" title="testForward(std::move(x))"></a>testForward(std::move(x))</h4><p>接下来，考虑<code>testForward(std::move(x))</code>的情况。</p><h5 id="step-1-实例化testForward-1"><a href="#step-1-实例化testForward-1" class="headerlink" title="step 1 实例化testForward"></a>step 1 实例化testForward</h5><p><code>testForward(std::move(x))</code>也就是<code>testForward(static_cast&lt;int &amp;&amp;&gt;(x))</code>。根据万能引用的实例化规则，实例化的testForward大概长这样：<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">T <span class="token operator">=</span> <span class="token keyword">int</span> <span class="token keyword">void</span> <span class="token function">testForward</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span> v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">print</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br>万能引用绑定到右值上时，不会发生引用折叠，所以这里没有引用折叠。</p><h5 id="step-2-实例化std-forward-1"><a href="#step-2-实例化std-forward-1" class="headerlink" title="step 2 实例化std::forward"></a>step 2 实例化std::forward</h5><blockquote><p>注：C++ Primer：forward必须通过显式模板实参来调用，不能依赖函数模板参数推导。</p><p>这里用到的std::forward的代码和上面的一样，故略去。</p><p>由于Step1中我们调用<code>std::forward&lt;int&gt;</code>，所以此处我们代入<code>T = int</code>，我们有：<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span><span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token operator">::</span>remove_reference<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">&amp;</span> __t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token comment">//remove_reference的作用与名字一致，不过多解释</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>__t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>这里又发生了2次引用折叠，所以上面的代码等价于：<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span><span class="token function">forward</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span> __t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token comment">//remove_reference的作用与名字一致，不过多解释</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>__t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>所以最终<code>std::forward&lt;int&gt;(v)</code>的作用就是将参数强制转型成<code>int &amp;&amp;</code>，而<code>int &amp;&amp;</code>为右值。所以，调用右值版本的print。</p></blockquote><h3 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h3><p>在GCC源码中，std::forward还有第二个版本：<a href="https://gcc.gnu.org/onlinedocs/gcc-5.4.0/libstdc++/api/a01395_source.html#l00087">link</a>，分析的方法与本文一致，这里就不讲了。。</p><p>右值的概念其实很微妙，一旦某个右值，有了名字，也就在内存中有了位置，它就变成了1个左值。但它又是一个很有用的概念，<strong>允许程序员更加细粒度的处理对象拷贝时的内存分配问题，提高了对临时对象和不需要的对象的利用率</strong>，极大提高程序的效率。当然，也会引入更多的bug。不过，这就是C++的哲学，什么都允许你做，但出了问题，可别赖C++这门语言。</p><p>完美转发基于万能引用，引用折叠以及std::forward模板函数。据我所知，STL出现std::forward，一定出现万能引用。其实这也很好理解，完美转发机制，是为了将左值和右值统一处理，节约代码量，而只有万能引用会出现同时接受左值和右值的情况，所以完美转发只存在于万能引用中。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Template </tag>
            
            <tag> C++ STL </tag>
            
            <tag> GNU C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XML 与 JSON 在设计目的和应用场景上的区别</title>
      <link href="2021/02/21/others/xml-yu-json-zai-she-ji-mu-de-he-ying-yong-chang-jing-shang-de-qu-bie/"/>
      <url>2021/02/21/others/xml-yu-json-zai-she-ji-mu-de-he-ying-yong-chang-jing-shang-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>今天在看《第一行代码》中关于SharedPreference的部分时，突然觉得用XML保存数据很不方便，比如如果要储存数组，用JSON中一行代码就可以解决的问题，XML还得自己写一些代码，比如：<a href="https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/3876680/is-it-possible-to-add-an-array-or-object-to-sharedpreferences-on-android">Is it possible to add an array or object to SharedPreferences on Android</a>。</p><p>所以我很好奇，XML在竞争如此激烈的时代，还在广泛被使用，是因为它是一个无法解决的历史遗留问题，还是因为XML确实有比JSON更优越的地方。</p><blockquote><p>注：以下部分段落节选并翻译自<a href="https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/2620270/what-is-the-difference-between-json-and-xml">StackOverflow</a>，不代表本人观点。</p></blockquote><h2 id="XML与JSON最本质的区别"><a href="#XML与JSON最本质的区别" class="headerlink" title="XML与JSON最本质的区别"></a>XML与JSON最本质的区别</h2><blockquote><p><a href="https://link.zhihu.com/?target=https%3A//stackoverflow.com/a/2620466/6109336">来源</a>，我做了一些注解</p></blockquote><p>最根本上来说，XML是一个markup language（标记语言），而JSON是一种用于数据交换（data-interchange）的序列化对象的语言。</p><p>根据Wiki的说法，标记语言是：</p><blockquote><p>In computer text processing, a markup language is a system for annotating a document in a way that is syntactically distinguishable from the text, meaning when the document is processed for display, the markup language is not shown, and is only used to format the text.</p></blockquote><p>标记语言除了文本信息，还包括了一些元信息，这些元信息用来标注如何处理文本信息，比如：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Document</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Paragraph</span> <span class="token attr-name">Align</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Center<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                 <span class="token comment">&lt;!-- Align是元信息 --></span>        Here <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Bold</span><span class="token punctuation">></span></span>is<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Bold</span><span class="token punctuation">></span></span> some text.    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Paragraph</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Document</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假如试图用JSON完完整整的表述上述的信息：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token property">"Paragraphs"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>            <span class="token property">"align"</span><span class="token operator">:</span> <span class="token string">"center"</span><span class="token punctuation">,</span>            <span class="token property">"content"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token string">"Here "</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>                    <span class="token property">"style"</span> <span class="token operator">:</span> <span class="token string">"bold"</span><span class="token punctuation">,</span>                    <span class="token property">"content"</span><span class="token operator">:</span> <span class="token punctuation">[</span> <span class="token string">"is"</span> <span class="token punctuation">]</span>                <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>                <span class="token string">" some text."</span>            <span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>是不是觉得JSON比XML还要复杂的多？</p><p>原因在于，JSON里面没有<strong>元数据和数据的区别</strong>，<strong>所有的东西都是数据</strong>，所以要人为的加上一些多余的字符串（比如content）进行区分。</p><hr><p>同样的，XML也不擅长做JSON所擅长做的事，那就是序列化对象：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token property">"firstName"</span><span class="token operator">:</span> <span class="token string">"Homer"</span><span class="token punctuation">,</span>    <span class="token property">"lastName"</span><span class="token operator">:</span> <span class="token string">"Simpson"</span><span class="token punctuation">,</span>    <span class="token property">"relatives"</span><span class="token operator">:</span> <span class="token punctuation">[</span> <span class="token string">"Grandpa"</span><span class="token punctuation">,</span> <span class="token string">"Marge"</span><span class="token punctuation">,</span> <span class="token string">"The Boy"</span><span class="token punctuation">,</span> <span class="token string">"Lisa"</span><span class="token punctuation">,</span> <span class="token string">"I think that's all of them"</span> <span class="token punctuation">]</span><span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果用XML表示上述对象：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Person</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>FirstName</span><span class="token punctuation">></span></span>Homer<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>FirstName</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>LastName</span><span class="token punctuation">></span></span>Simpsons<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>LastName</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Relatives</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Relative</span><span class="token punctuation">></span></span>Grandpa<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Relative</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Relative</span><span class="token punctuation">></span></span>Marge<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Relative</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Relative</span><span class="token punctuation">></span></span>The Boy<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Relative</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Relative</span><span class="token punctuation">></span></span>Lisa<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Relative</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Relative</span><span class="token punctuation">></span></span>I think that's all of them<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Relative</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Relatives</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Person</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从这个例子可以看到JSON有2点优于XML的地方：</p><ul><li>对象的内部结构一目了然，简洁明了。</li><li>JSON语法规定[]是数组，{}是对象，而XML没有如此的语法规定，我们只能临时发明一种方式来表示数组，然后自己添加代码来识别这个数组。</li></ul><p>如果我们人为施加一种策略，那么XML的确可以完成JSON的工作，但是JSON本身内建了这种策略。</p><p>比如<a href="https://link.zhihu.com/?target=https%3A//stackoverflow.com/a/7998630/6109336">这里</a>，有人提出了XJSON，可以用XML完成JSON的工作：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xjson</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>object</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>persons<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>array</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>object</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>Ford Prefect<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>gender</span><span class="token punctuation">></span></span>male<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>gender</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>object</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>object</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>Arthur Dent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>gender</span><span class="token punctuation">></span></span>male<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>gender</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>object</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>object</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>Tricia McMillan<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>gender</span><span class="token punctuation">></span></span>female<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>gender</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>object</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>array</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>object</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xjson</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>Once you wrote an XJSON processor, it could do exactly what JSON processor does, for all the types of data that JSON can represent, and you could translate data losslessly between JSON and XJSON.<br>如果你写出一个针对XJSON的解析包，那么它可以完成JSON所有的工作。</p></blockquote><p>不过，这未免也太眼花缭乱了一些。</p><p>所以在表示对象这个问题上面，JSON是远比XML优越的一种语言。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>在我看来，XML和JSON是乍一看有点相似，但设计出发点和应用场景却并不重叠的语言。</p><p>就好像以前我发现MATLAB除了可以做矩阵计算，还可以写GUI，但我觉得不会有人真的用它去写复杂的GUI界面。Python这种语言似乎很万能很流行，什么都可以做，甚至游戏，但不会真的有人去用Python去写游戏引擎的底层部分。</p><p>延伸阅读：</p><p><a href="https://www.zhihu.com/question/25636060">为什么都反对 XML 而支持使用 JSON？</a></p><p>（END）</p>]]></content>
      
      
      <categories>
          
          <category> 编程随想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XML </tag>
            
            <tag> JSON </tag>
            
            <tag> 没什么用 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
