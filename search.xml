<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>完美转发 = 引用折叠 + 万能引用 + std::forward</title>
      <link href="2021/04/29/cpp/wan-mei-zhuan-fa-yin-yong-zhe-die-wan-neng-yin-yong-std-forward/"/>
      <url>2021/04/29/cpp/wan-mei-zhuan-fa-yin-yong-zhe-die-wan-neng-yin-yong-std-forward/</url>
      
        <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>完美转发是一个比较简单，却又比较复杂的东西。</p><p>简单之处在于理解<strong>动机</strong>：C++为什么需要完美转发？</p><p>复杂之处在于理解<strong>原理</strong>：完美转发基于万能引用，引用折叠以及std::forward模板函数。</p><p>本文将会结合GCC源码，详细解读完美转发的动机和原理。</p><h3 id="动机：C-为什么需要完美转发？"><a href="#动机：C-为什么需要完美转发？" class="headerlink" title="动机：C++为什么需要完美转发？"></a>动机：C++为什么需要完美转发？</h3><p>我们从一个简单的例子出发。<br>假设有这么一种情况，用户一般使用testForward函数，testForward什么也不做，只是简单的转调用到print函数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span> t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Lvalue ref"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>T <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Rvalue ref"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">testForward</span><span class="token punctuation">(</span>T <span class="token operator">&amp;&amp;</span> v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>     <span class="token function">print</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//v此时已经是个左值了,永远调用左值版本的print</span>    <span class="token function">print</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//本文的重点</span>    <span class="token function">print</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//永远调用右值版本的print</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"======================"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">testForward</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//实参为左值</span>    <span class="token function">testForward</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//实参为右值</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的程序的运行结果：</p><pre class="line-numbers language-none"><code class="language-none">Lvalue refLvalue refRvalue ref&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Lvalue refRvalue refRvalue ref&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用户希望<code>testForward(x);</code>最终调用的是左值版本的print，而<code>testForward(std::move(x));</code>最终调用的是右值版本的print。</p><p><strong>可惜的是，在testForward中，虽然参数v是右值类型的，但此时v在内存中已经有了位置，所以v其实是个左值！</strong></p><p>所以，<code>print(v)</code>永远调用左值版本的print，与用户的本意不符。<code>print(std::move(v));</code>永远调用右值版本的print，与用户的本意也不符。只有<code>print(std::forward&lt;T&gt;(v));</code>才符合用户的本意，这就是本文的主题。</p><p>不难发现，本质问题在于，左值右值在函数调用时，都转化成了左值，使得函数转调用时无法判断左值和右值。</p><p>在STL中，随处可见这种问题。比如C++11引入的<code>emplace_back</code>，它接受左值也接受右值作为参数，接着，它转调用了空间配置器的construct函数，而construct又转调用了<code>placement new</code>，<code>placement new</code>根据参数是左值还是右值，决定调用拷贝构造函数还是移动构造函数。</p><p>这里要保证从<code>emplace_back</code>到<code>placement new</code>，参数的左值和右值属性保持不变。这其实不是一件简单的事情。</p><h3 id="前置知识-引用折叠-万能引用"><a href="#前置知识-引用折叠-万能引用" class="headerlink" title="前置知识 引用折叠 万能引用"></a>前置知识 引用折叠 万能引用</h3><p>C++ Primer 里面写的比较容易理解，在P608（我的是第5版）。<br>略</p><h3 id="原理：完美转发"><a href="#原理：完美转发" class="headerlink" title="原理：完美转发"></a>原理：完美转发</h3><p>std::forward不是独自运作的，在我的理解里，完美转发 = std::forward + 万能引用 + 引用折叠。三者合一才能实现完美转发的效果。</p><p>std::forward的正确运作的前提，是引用折叠机制，为T &amp;&amp;类型的万能引用中的模板参数T赋了一个恰到好处的值。我们用T去指明std::forward<T>的模板参数，从而使得std::forward返回的是正确的类型。</p><p>当然，我们还是先回到一开始的例子。</p><h4 id="testForward-x"><a href="#testForward-x" class="headerlink" title="testForward(x)"></a>testForward(x)</h4><p>回到上面的例子。先考虑<code>testForward(x);</code>这一行代码。</p><h5 id="step-1-实例化testForward"><a href="#step-1-实例化testForward" class="headerlink" title="step 1 实例化testForward"></a>step 1 实例化testForward</h5><p>根据万能引用的实例化规则，实例化的testForward大概长这样：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">T <span class="token operator">=</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span><span class="token keyword">void</span> <span class="token function">testForward</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span> <span class="token operator">&amp;&amp;</span> v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">print</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>又根据引用折叠，上面的等价于下面的代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">T <span class="token operator">=</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span><span class="token keyword">void</span> <span class="token function">testForward</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span> v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">print</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果你正确的理解了引用折叠，那么这一步是很好理解的。</p><h5 id="step-2-实例化std-forward"><a href="#step-2-实例化std-forward" class="headerlink" title="step 2 实例化std::forward"></a>step 2 实例化std::forward</h5><blockquote><p>注：C++ Primer：forward必须通过显式模板实参来调用，不能依赖函数模板参数推导。</p></blockquote><p>接下来我们来看下<code>std::forward</code>在libstdc++中的实现：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token number">68</span>   <span class="token comment">/**69    *  @brief  Forward an lvalue.70    *  @return The parameter cast to the specified type.71    *72    *  This function is used to implement "perfect forwarding".73    */</span><span class="token number">74</span>   <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">_Tp</span><span class="token operator">></span><span class="token number">75</span>     <span class="token keyword">constexpr</span> _Tp<span class="token operator">&amp;&amp;</span><span class="token number">76</span>     <span class="token function">forward</span><span class="token punctuation">(</span><span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token operator">::</span>remove_reference<span class="token operator">&lt;</span>_Tp<span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">&amp;</span> __t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token number">77</span>     <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>_Tp<span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>__t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于Step1中我们调用<code>std::forward&lt;int &amp;&gt;</code>，所以此处我们代入<code>T = int &amp;</code>，我们有：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span> <span class="token operator">&amp;&amp;</span> <span class="token comment">//折叠</span><span class="token function">forward</span><span class="token punctuation">(</span><span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token operator">::</span>remove_reference<span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span><span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">&amp;</span> __t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token comment">//remove_reference的作用与名字一致，不过多解释</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span> <span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>__t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//折叠</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里又发生了2次引用折叠，所以上面的代码等价于：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span> <span class="token comment">//折叠</span><span class="token function">forward</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span> __t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token comment">//remove_reference的作用与名字一致，不过多解释</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>__t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//折叠</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>所以最终<code>std::forward&lt;int &amp;&gt;(v)</code>的作用就是将参数强制转型成<code>int &amp;</code>，而<code>int &amp;</code>为左值。所以，调用左值版本的print。</p><h4 id="testForward-std-move-x"><a href="#testForward-std-move-x" class="headerlink" title="testForward(std::move(x))"></a>testForward(std::move(x))</h4><p>接下来，考虑<code>testForward(std::move(x))</code>的情况。</p><h5 id="step-1-实例化testForward-1"><a href="#step-1-实例化testForward-1" class="headerlink" title="step 1 实例化testForward"></a>step 1 实例化testForward</h5><p><code>testForward(std::move(x))</code>也就是<code>testForward(static_cast&lt;int &amp;&amp;&gt;(x))</code>。根据万能引用的实例化规则，实例化的testForward大概长这样：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">T <span class="token operator">=</span> <span class="token keyword">int</span> <span class="token keyword">void</span> <span class="token function">testForward</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span> v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">print</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>万能引用绑定到右值上时，不会发生引用折叠，所以这里没有引用折叠。</p><h5 id="step-2-实例化std-forward-1"><a href="#step-2-实例化std-forward-1" class="headerlink" title="step 2 实例化std::forward"></a>step 2 实例化std::forward</h5><blockquote><p>注：C++ Primer：forward必须通过显式模板实参来调用，不能依赖函数模板参数推导。</p></blockquote><blockquote><p>这里用到的std::forward的代码和上面的一样，故略去。</p></blockquote><p>由于Step1中我们调用<code>std::forward&lt;int&gt;</code>，所以此处我们代入<code>T = int</code>，我们有：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span><span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token operator">::</span>remove_reference<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">&amp;</span> __t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token comment">//remove_reference的作用与名字一致，不过多解释</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>__t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里又发生了2次引用折叠，所以上面的代码等价于：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span><span class="token function">forward</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span> __t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token comment">//remove_reference的作用与名字一致，不过多解释</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>__t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>所以最终<code>std::forward&lt;int&gt;(v)</code>的作用就是将参数强制转型成<code>int &amp;&amp;</code>，而<code>int &amp;&amp;</code>为右值。所以，调用右值版本的print。</p><h3 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h3><p>在GCC源码中，std::forward还有第二个版本：<a href="https://gcc.gnu.org/onlinedocs/gcc-5.4.0/libstdc++/api/a01395_source.html#l00087">link</a>，分析的方法与本文一致，这里就不讲了。。</p><p>右值的概念其实很微妙，一旦某个右值，有了名字，也就在内存中有了位置，它就变成了1个左值。但它又是一个很有用的概念，<strong>允许程序员更加细粒度的处理对象拷贝时的内存分配问题，提高了对临时对象和不需要的对象的利用率</strong>，极大提高程序的效率。当然，也会引入更多的bug。不过，这就是C++的哲学，什么都允许你做，但出了问题，可别赖C++这门语言。</p><p>完美转发基于万能引用，引用折叠以及std::forward模板函数。据我所知，STL出现std::forward，一定出现万能引用。其实这也很好理解，完美转发机制，是为了将左值和右值统一处理，节约代码量，而只有万能引用会出现同时接受左值和右值的情况，所以完美转发只存在于万能引用中。</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
